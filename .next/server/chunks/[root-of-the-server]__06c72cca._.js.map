{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/theek/Documents/DA%20Project/smart-parts/web/src/app/api/stripe/webhook/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport Stripe from \"stripe\";\r\n\r\nexport const config = { api: { bodyParser: false } }; // (ignored in app router, left for reference)\r\n\r\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\r\n  apiVersion: \"2025-09-30.clover\",\r\n});\r\n\r\n// Raw body reader for app router\r\nasync function buffer(readable: ReadableStream<Uint8Array>) {\r\n  const reader = readable.getReader();\r\n  const chunks: Uint8Array[] = [];\r\n  // @ts-ignore\r\n  while (true) {\r\n    const { done, value } = await reader.read();\r\n    if (done) break;\r\n    if (value) chunks.push(value);\r\n  }\r\n  return Buffer.concat(chunks);\r\n}\r\n\r\nexport async function POST(req: NextRequest) {\r\n  const sig = req.headers.get(\"stripe-signature\");\r\n  if (!sig) return new NextResponse(\"Missing signature\", { status: 400 });\r\n\r\n  const buf = await buffer(req.body!);\r\n  let event: Stripe.Event;\r\n\r\n  try {\r\n    event = stripe.webhooks.constructEvent(\r\n      buf,\r\n      sig,\r\n      process.env.STRIPE_WEBHOOK_SECRET!\r\n    );\r\n  } catch (err: any) {\r\n    console.error(\"Webhook signature verification failed.\", err.message);\r\n    return new NextResponse(`Webhook Error: ${err.message}`, { status: 400 });\r\n  }\r\n\r\n  try {\r\n    switch (event.type) {\r\n      case \"checkout.session.completed\": {\r\n        const session = event.data.object as Stripe.Checkout.Session;\r\n\r\n        // Example: finalize order in your system\r\n        // You may fetch line items to know what was purchased:\r\n        const lineItems = await stripe.checkout.sessions.listLineItems(session.id);\r\n\r\n        // Call your internal order creation logic\r\n        // await createOrderFromStripe(session, lineItems)   // implement this\r\n        // or call your existing endpoint:\r\n        // await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/orders/checkout`, { method: \"POST\", headers: { \"x-internal-key\": process.env.INTERNAL_KEY! } })\r\n\r\n        break;\r\n      }\r\n      default:\r\n        // Handle other events if needed\r\n        break;\r\n    }\r\n    return NextResponse.json({ received: true }, { status: 200 });\r\n  } catch (err: any) {\r\n    console.error(\"Webhook processing error:\", err);\r\n    return new NextResponse(\"Webhook handler failed\", { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEO,MAAM,SAAS;IAAE,KAAK;QAAE,YAAY;IAAM;AAAE,GAAG,8CAA8C;AAEpG,MAAM,SAAS,IAAI,mKAAM,CAAC,QAAQ,GAAG,CAAC,iBAAiB,EAAG;IACxD,YAAY;AACd;AAEA,iCAAiC;AACjC,eAAe,OAAO,QAAoC;IACxD,MAAM,SAAS,SAAS,SAAS;IACjC,MAAM,SAAuB,EAAE;IAC/B,aAAa;IACb,MAAO,KAAM;QACX,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,OAAO,IAAI;QACzC,IAAI,MAAM;QACV,IAAI,OAAO,OAAO,IAAI,CAAC;IACzB;IACA,OAAO,OAAO,MAAM,CAAC;AACvB;AAEO,eAAe,KAAK,GAAgB;IACzC,MAAM,MAAM,IAAI,OAAO,CAAC,GAAG,CAAC;IAC5B,IAAI,CAAC,KAAK,OAAO,IAAI,gJAAY,CAAC,qBAAqB;QAAE,QAAQ;IAAI;IAErE,MAAM,MAAM,MAAM,OAAO,IAAI,IAAI;IACjC,IAAI;IAEJ,IAAI;QACF,QAAQ,OAAO,QAAQ,CAAC,cAAc,CACpC,KACA,KACA,QAAQ,GAAG,CAAC,qBAAqB;IAErC,EAAE,OAAO,KAAU;QACjB,QAAQ,KAAK,CAAC,0CAA0C,IAAI,OAAO;QACnE,OAAO,IAAI,gJAAY,CAAC,CAAC,eAAe,EAAE,IAAI,OAAO,EAAE,EAAE;YAAE,QAAQ;QAAI;IACzE;IAEA,IAAI;QACF,OAAQ,MAAM,IAAI;YAChB,KAAK;gBAA8B;oBACjC,MAAM,UAAU,MAAM,IAAI,CAAC,MAAM;oBAEjC,yCAAyC;oBACzC,uDAAuD;oBACvD,MAAM,YAAY,MAAM,OAAO,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,QAAQ,EAAE;oBAOzE;gBACF;YACA;gBAEE;QACJ;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,UAAU;QAAK,GAAG;YAAE,QAAQ;QAAI;IAC7D,EAAE,OAAO,KAAU;QACjB,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,IAAI,gJAAY,CAAC,0BAA0B;YAAE,QAAQ;QAAI;IAClE;AACF","debugId":null}}]
}